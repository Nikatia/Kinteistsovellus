@model Kiinteistosovellus.Models.OtherSpendingTypes


@using (Html.BeginForm("_ModalCreateOthSpendingType", "OtherSpendings", FormMethod.Post, new { id = "createTypeForm" }))
{
    @Html.AntiForgeryToken()

    <div class="form-horizontal">
        @Html.ValidationSummary(true, "", new { @class = "text-danger" })
        <div class="form-group">
            <div class="col-md-10">
                @Html.EditorFor(model => model.TypeName, new { htmlAttributes = new { @class = "form-control" } })
                @Html.ValidationMessageFor(model => model.TypeName, "", new { @class = "text-danger", @id="realErrorTypeName" }) @*Täytyy antaa id*@
            </div>
        </div>
        @Html.TextBoxFor(model => model.LoginID, "LoginID", new { @class = "form-control", @Value = ViewBag.LoginID, @Hidden = "true" })
    </div>
}

<script>
    $(document).ready(function () {//Kun partial view-lautautuu, kenttiä päivitetään
        var realErrorTypeName = document.getElementById("realErrorTypeName"); //luodaan muuttuja oikealle errormessage-elementille
        var fakeErrorTypeName = document.getElementById("fakeErrorTypeName");//luodaan muuttuja väärälle errormessage-elementille

        if (realErrorTypeName.innerText != "") {
            fakeErrorTypeName.innerText = realErrorTypeName.innerText; //Hos realErrorTypeName pitää sisällään jotain tekstiä eli errorin, errori lisätään myös feikki inputille
        } else {
            fakeErrorTypeName.innerText = ""; //Poistetaan manuaaluisesti feikki errormessage
            document.getElementById("fakeFormTypeName").value = ""; //tyjennetään kumpikin kenttä
            document.getElementById("TypeName").value = "";//tyjennetään kumpikin kenttä
        }
    });
</script>
